<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>地铁站 V7.0 | 全平台适配版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a20; font-family: sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }

        /* UI 层 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 25, 30, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 100; transition: opacity 0.3s;
        }
        
        button {
            padding: 15px 40px; font-size: 1.2rem; background: #4af; color: #000; 
            border: none; border-radius: 30px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 20px rgba(68, 170, 255, 0.4); margin-top: 20px;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
            box-shadow: 0 0 4px #000;
        }

        #msg {
            position: absolute; top: 20%; width: 100%; text-align: center; color: #ff0; 
            text-shadow: 0 0 5px #000; font-size: 1.2rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20;
        }

        /* 移动端摇杆 UI */
        .joystick-zone {
            position: absolute; bottom: 40px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; display: none; /* 默认隐藏，JS检测到移动端开启 */
            touch-action: none; z-index: 50;
        }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }
        
        .knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        #pc-hint {
            position: absolute; bottom: 20px; left: 20px; color: #aaa; pointer-events: none; font-size: 0.9rem;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h2 style="color: #4af;">STATION V7.0</h2>
        <p style="color: #bbb;">亮度提升 • 移动端适配 • 强力物理</p>
        <button id="start-btn">开始体验 / START</button>
    </div>

    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    <div id="msg"></div>
    
    <!-- PC提示 -->
    <div id="pc-hint">WASD移动 | Shift加速 | 鼠标交互</div>

    <!-- 移动端摇杆 -->
    <div id="stick-left" class="joystick-zone"><div class="knob" id="knob-l"></div></div>
    <div id="stick-right" class="joystick-zone"><div class="knob" id="knob-r"></div></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 全局配置 ---
        const CONFIG = {
            gravity: 30.0,
            walkSpeed: 12.0,
            runSpeed: 25.0,
            lookSensitivityMobile: 2.0,
            playerHeight: 1.6,
            playerRadius: 0.5
        };

        let camera, scene, renderer, controls;
        let isMobile = false;
        let lastTime = performance.now();
        
        // 输入状态
        const input = { x: 0, y: 0, run: false }; // x,y 用于移动向量 (-1 to 1)
        const touchLook = { x: 0, y: 0 }; // 用于旋转视角
        
        // 物理状态
        const velocity = new THREE.Vector3();
        let canJump = false;
        const colliders = [];

        // 场景对象
        let trainGroup, trainBodyMesh;
        let trainActive = false, trainTimer = 0;
        const trainBox = new THREE.Box3();
        let vmLight;

        // 音频
        let audioCtx, masterGain;

        init();
        animate();

        function init() {
            // 0. 检测平台
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if(isMobile) {
                document.getElementById('pc-hint').style.display = 'none';
                document.getElementById('stick-left').style.display = 'block';
                document.getElementById('stick-right').style.display = 'block';
            }

            // 1. 渲染器 (高亮度设置)
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            // 开启物理光照修正
            renderer.useLegacyLights = false; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // 全局曝光提升，解决"太黑"
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 2. 场景 (颜色调亮)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222228); // 深蓝灰背景，不再死黑
            scene.fog = new THREE.FogExp2(0x222228, 0.015); // 雾气变淡

            // 3. 相机
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(10, 2, 0);
            // 修正相机旋转顺序，方便手机触摸控制
            camera.rotation.order = 'YXZ'; 

            // 4. 灯光 (大幅增强)
            const ambient = new THREE.AmbientLight(0xffffff, 1.5); // 强环境光
            scene.add(ambient);
            
            const dirLight = new THREE.DirectionalLight(0xffeedd, 1.0);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            // 5. 交互控制器 (PC使用PointerLock，手机自定义)
            if (!isMobile) {
                controls = new PointerLockControls(camera, document.body);
            }

            const btn = document.getElementById('start-btn');
            const overlay = document.getElementById('overlay');
            
            btn.addEventListener('click', async () => {
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 300);
                
                await initAudio();
                startLoop();
                setInterval(triggerTrain, 12000);

                if (!isMobile) {
                    controls.lock();
                } else {
                    // 手机端全屏
                    if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
                }
            });

            if(!isMobile) {
                controls.addEventListener('unlock', () => {
                    overlay.style.display = 'flex';
                    overlay.style.opacity = 1;
                });
            }

            // 6. 输入监听
            setupInputs();

            // 7. 构建场景
            buildLevel();

            window.addEventListener('resize', onResize);
        }

        // --- 输入系统 (PC & Mobile 统一) ---
        function setupInputs() {
            // PC 键盘
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': input.y = 1; break;
                    case 'KeyS': input.y = -1; break;
                    case 'KeyA': input.x = -1; break;
                    case 'KeyD': input.x = 1; break;
                    case 'ShiftLeft': input.run = true; break;
                    case 'Space': if(canJump) velocity.y = CONFIG.gravity * 0.4; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': if(input.y===1) input.y=0; break;
                    case 'KeyS': if(input.y===-1) input.y=0; break;
                    case 'KeyA': if(input.x===-1) input.x=0; break;
                    case 'KeyD': if(input.x===1) input.x=0; break;
                    case 'ShiftLeft': input.run = false; break;
                }
            });
            document.addEventListener('click', onInteract);

            // 移动端 触摸摇杆
            if(isMobile) {
                setupJoystick('stick-left', 'knob-l', (x, y) => {
                    input.x = x; input.y = -y; // 摇杆向上是y-，我们需要前进
                });
                setupJoystick('stick-right', 'knob-r', (x, y) => {
                    touchLook.x = x * CONFIG.lookSensitivityMobile;
                    touchLook.y = y * CONFIG.lookSensitivityMobile;
                });
                
                // 手机跳跃：点击屏幕上半部分？或者简单点，双指点击屏幕
                document.addEventListener('touchstart', (e) => {
                    if(e.touches.length > 1 && canJump) velocity.y = CONFIG.gravity * 0.4;
                    // 手机交互检测
                    if(e.target.id === 'canvas-container' || e.target.tagName === 'CANVAS') {
                         onInteract();
                    }
                }, {passive: false});
            }
        }

        function setupJoystick(zoneId, knobId, callback) {
            const zone = document.getElementById(zoneId);
            const knob = document.getElementById(knobId);
            const rect = zone.getBoundingClientRect();
            const center = { x: rect.width/2, y: rect.height/2 };
            let touchId = null;

            zone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                updateKnob(touch.clientX, touch.clientY);
            });

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        updateKnob(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            });

            zone.addEventListener('touchend', (e) => {
                e.preventDefault();
                knob.style.transform = `translate(-50%, -50%)`;
                callback(0, 0); // Reset
            });

            function updateKnob(clientX, clientY) {
                // 重新获取rect防止滚动
                const zoneRect = zone.getBoundingClientRect();
                const centerX = zoneRect.left + zoneRect.width/2;
                const centerY = zoneRect.top + zoneRect.height/2;
                
                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = zoneRect.width/2 - 25; // 25 is half knob size

                if (dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }

                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Normalize -1 to 1
                callback(dx / maxDist, dy / maxDist);
            }
        }

        // --- 场景构建 ---
        function generateTexture() {
            // 生成亮灰色的水泥纹理
            const c = document.createElement('canvas');
            c.width = 256; c.height = 256;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#888899'; // 亮底色
            ctx.fillRect(0,0,256,256);
            for(let i=0; i<5000; i++) {
                ctx.fillStyle = Math.random()>0.5 ? '#999' : '#777';
                ctx.fillRect(Math.random()*256, Math.random()*256, 2, 2);
            }
            const t = new THREE.CanvasTexture(c);
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
            t.repeat.set(10, 10);
            return t;
        }

        function buildLevel() {
            const tex = generateTexture();
            const matFloor = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8 });
            const matWall = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.5 }); // 亮墙壁

            // 1. 地板
            const floor = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 300), matFloor);
            floor.position.set(10, -0.5, 0);
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. 轨道
            const track = new THREE.Mesh(new THREE.BoxGeometry(30, 1, 300), new THREE.MeshStandardMaterial({color: 0x111}));
            track.position.set(-15, -3.5, 0);
            scene.add(track);

            // 3. 墙壁 & 碰撞体
            const wall = new THREE.Mesh(new THREE.BoxGeometry(2, 20, 300), matWall);
            wall.position.set(21, 10, 0);
            wall.castShadow = true;
            scene.add(wall);
            colliders.push(new THREE.Box3().setFromObject(wall)); // 后墙

            // 边界空气墙
            colliders.push(new THREE.Box3(new THREE.Vector3(-100,-100,-152), new THREE.Vector3(100,100,-150)));
            colliders.push(new THREE.Box3(new THREE.Vector3(-100,-100,150), new THREE.Vector3(100,100,152)));
            colliders.push(new THREE.Box3(new THREE.Vector3(-40,-100,-200), new THREE.Vector3(-30,100,200))); // 轨道深处墙

            // 4. 柱子
            const colGeo = new THREE.BoxGeometry(1.5, 12, 1.5);
            for(let z=-100; z<=100; z+=25) {
                const c = new THREE.Mesh(colGeo, matWall);
                c.position.set(5, 6, z);
                c.castShadow = true;
                scene.add(c);
                colliders.push(new THREE.Box3().setFromObject(c));

                const l = new THREE.PointLight(0xddeeff, 1, 15);
                l.position.set(5, 8, z);
                scene.add(l);
            }

            // 5. 售货机 (修复穿模：硬编码碰撞盒)
            const vmGroup = new THREE.Group();
            const vmMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), new THREE.MeshStandardMaterial({color: 0x333, roughness: 0.1}));
            vmMesh.position.y = 2; 
            vmGroup.add(vmMesh);
            
            // 屏幕
            const sc = new THREE.Mesh(new THREE.PlaneGeometry(1.5,1), new THREE.MeshBasicMaterial({color:0x00ff00}));
            sc.position.set(0,2.5,-1.01);
            sc.rotation.y = Math.PI;
            vmGroup.add(sc);
            vmLight = new THREE.PointLight(0x00ff00, 1, 4);
            vmLight.position.set(0,2.5,-1.5);
            vmGroup.add(vmLight);

            vmGroup.position.set(18, 0, 10);
            vmGroup.name = 'vending_machine';
            scene.add(vmGroup);

            // *** 核心修复：手动添加售货机碰撞盒 ***
            // 售货机在 (18, 0, 10), 大小 2x4x2. 
            // 范围 x:[17, 19], y:[0, 4], z:[9, 11]
            // 为了保险，我们把它扩大一点点 (16.8 - 19.2)
            const vmBox = new THREE.Box3(
                new THREE.Vector3(16.8, 0, 8.8),
                new THREE.Vector3(19.2, 5, 11.2)
            );
            colliders.push(vmBox);

            // 6. 列车
            trainGroup = new THREE.Group();
            trainBodyMesh = new THREE.Mesh(new THREE.BoxGeometry(4.2, 4.5, 80), new THREE.MeshStandardMaterial({color: 0xcccccc, metalness:0.7}));
            trainBodyMesh.position.y = 2.25;
            trainGroup.add(trainBodyMesh);
            const tLight = new THREE.SpotLight(0xffffff, 100, 150);
            tLight.position.set(0,2,41); tLight.target.position.set(0,0,100);
            trainGroup.add(tLight); trainGroup.add(tLight.target);
            trainGroup.position.set(-6, -3, -400);
            scene.add(trainGroup);
        }

        // --- 逻辑循环 ---
        function updatePhysics(dt) {
            // 阻尼
            velocity.x -= velocity.x * 10 * dt;
            velocity.z -= velocity.z * 10 * dt;
            velocity.y -= CONFIG.gravity * dt;

            // 移动输入处理
            const speed = input.run ? CONFIG.runSpeed : CONFIG.walkSpeed;
            // 获取相机水平方向
            const forward = new THREE.Vector3(); 
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

            // 组合输入 (WASD + Joystick)
            if (input.y !== 0) {
                velocity.x += forward.x * speed * input.y * dt * 10;
                velocity.z += forward.z * speed * input.y * dt * 10;
            }
            if (input.x !== 0) {
                velocity.x += right.x * speed * input.x * dt * 10;
                velocity.z += right.z * speed * input.x * dt * 10;
            }

            // 移动端视角处理
            if(isMobile && (touchLook.x !== 0 || touchLook.y !== 0)) {
                camera.rotation.y -= touchLook.x * dt;
                // 限制抬头低头
                // Threejs rotation Euler order YXZ
                // 手动限制 Pitch
                // 这是一个简化处理，直接改 rotation.x
                camera.rotation.x -= touchLook.y * dt;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                
                // 阻尼回中? 不，保持
                touchLook.x = 0; touchLook.y = 0; // 单帧消耗
            }

            // 分轴碰撞
            function attemptMove(axis, amount) {
                camera.position[axis] += amount;
                if(checkCollision()) {
                    camera.position[axis] -= amount;
                    velocity[axis] = 0;
                }
            }
            attemptMove('x', velocity.x * dt);
            attemptMove('z', velocity.z * dt);
            camera.position.y += velocity.y * dt;

            // 地面
            const groundY = camera.position.x > 0 ? 0 : -3;
            if(camera.position.y < groundY + CONFIG.playerHeight) {
                camera.position.y = groundY + CONFIG.playerHeight;
                velocity.y = 0;
                canJump = true;
            } else {
                canJump = false;
            }

            if(camera.position.y < -50) { camera.position.set(10,2,0); velocity.set(0,0,0); }

            // 列车检测
            if(trainActive) {
                const pBox = new THREE.Box3();
                const r = CONFIG.playerRadius;
                pBox.min.set(camera.position.x-r, camera.position.y-1, camera.position.z-r);
                pBox.max.set(camera.position.x+r, camera.position.y, camera.position.z+r);
                trainBox.setFromObject(trainBodyMesh);
                if(trainBox.intersectsBox(pBox)) {
                    velocity.y = 15; velocity.x = 40; velocity.z = 10;
                    playHitSound();
                }
            }
        }

        function checkCollision() {
            const pBox = new THREE.Box3();
            const r = CONFIG.playerRadius;
            // 检测脚部和头部
            pBox.min.set(camera.position.x-r, camera.position.y-1.5, camera.position.z-r);
            pBox.max.set(camera.position.x+r, camera.position.y+0.2, camera.position.z+r);
            for(let b of colliders) if(b.intersectsBox(pBox)) return true;
            return false;
        }

        function onInteract() {
            // 简单的射线检测
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(scene.children, true);
            if(hits.length > 0 && hits[0].distance < 4) {
                let obj = hits[0].object;
                while(obj.parent && obj.parent !== scene) obj = obj.parent;
                if(obj.name === 'vending_machine') {
                    showMsg("库存不足 / OUT OF STOCK");
                    vmLight.color.setHex(0xff0000);
                    setTimeout(() => vmLight.color.setHex(0x00ff00), 500);
                    playHitSound();
                }
            }
        }

        function showMsg(txt) {
            const m = document.getElementById('msg');
            m.innerText = txt;
            m.style.opacity = 1;
            setTimeout(() => m.style.opacity = 0, 2000);
        }

        function triggerTrain() {
            if(trainActive) return;
            trainActive = true; trainTimer = 0;
            playTrainSound();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastTime)/1000, 0.1);
            lastTime = time;

            updatePhysics(dt);

            if(trainActive) {
                trainTimer += dt;
                const dur = 6.0;
                if(trainTimer < dur) trainGroup.position.z = -300 + 600*(trainTimer/dur);
                else { trainActive = false; trainGroup.position.z = -400; }
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 音频 ---
        async function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            if(audioCtx.state === 'suspended') await audioCtx.resume();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;
            masterGain.connect(audioCtx.destination);
        }

        function startLoop() {
            const osc = audioCtx.createOscillator();
            osc.frequency.value = 50;
            const g = audioCtx.createGain();
            g.gain.value = 0.05;
            osc.connect(g).connect(masterGain);
            osc.start();
        }

        function playTrainSound() {
            const t = audioCtx.currentTime;
            const b = audioCtx.createBuffer(1, audioCtx.sampleRate*6, audioCtx.sampleRate);
            const d = b.getChannelData(0);
            for(let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
            const src = audioCtx.createBufferSource();
            src.buffer = b;
            const f = audioCtx.createBiquadFilter();
            f.type = 'bandpass';
            f.frequency.setValueAtTime(100, t);
            f.frequency.linearRampToValueAtTime(1200, t+3);
            f.frequency.linearRampToValueAtTime(100, t+6);
            const pan = audioCtx.createPanner();
            pan.positionX.value = -6;
            pan.positionZ.setValueAtTime(-200, t);
            pan.positionZ.linearRampToValueAtTime(200, t+6);
            src.connect(f).connect(pan).connect(masterGain);
            src.start();
        }

        function playHitSound() {
            const t = audioCtx.currentTime;
            const o = audioCtx.createOscillator();
            o.type = 'square';
            o.frequency.setValueAtTime(150, t);
            o.frequency.exponentialRampToValueAtTime(20, t+0.3);
            const g = audioCtx.createGain();
            g.gain.value = 0.5;
            g.gain.exponentialRampToValueAtTime(0.01, t+0.3);
            o.connect(g).connect(masterGain);
            o.start(); o.stop(t+0.3);
        }
    </script>
</body>
</html>
