<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>深夜地铁站 | 终极修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* 画面样式：保留复古感，但不再过度模糊 */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* 关键：像素化而非模糊 */
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 100;
        }

        #start-btn {
            padding: 20px 50px; border: 2px solid #fff; background: #222; color: #fff;
            font-size: 1.5rem; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            transition: 0.2s;
        }
        #start-btn:hover { background: #fff; color: #000; box-shadow: 0 0 40px rgba(255,255,255,0.5); }

        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; 
            background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); 
        }
        
        #tips {
            position: absolute; bottom: 20px; left: 20px; color: #888; font-size: 0.9rem;
            text-shadow: 1px 1px 0 #000;
        }
        .highlight { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 style="color: #44aaff; text-shadow: 0 0 10px #44aaff;">深夜站台 V2.0</h1>
        <p style="margin-bottom: 30px; color: #888;">戴上耳机 • 只有一趟末班车</p>
        <button id="start-btn">点击进入 / 开启音频</button>
    </div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="tips">
            [WASD] 移动 <span class="highlight">[SHIFT] 疾跑</span><br>
            [鼠标] 视角<br>
            [点击] 交互
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 配置参数 ---
        const PIXEL_RATIO = 0.5; // 清晰度：0.5 = 半分辨率 (PS1风格但清晰)，之前是0.2太糊了
        const BASE_SPEED = 30.0;
        const RUN_SPEED = 80.0;
        const TRAIN_INTERVAL = 25000; // 25秒一班车

        // --- 全局变量 ---
        let camera, scene, renderer, controls;
        let moveF = false, moveB = false, moveL = false, moveR = false, isRunning = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // 场景对象
        let trainGroup; // 实体列车组
        let trainMoving = false; // 列车是否在运行
        let trainStartTime = 0;
        
        // 音频上下文
        let audioCtx, masterGain;
        let trainSoundNode = null;
        let ambienceNode = null;

        init();
        animate();

        function init() {
            // 1. 场景与迷雾
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            // 雾的浓度调整，防止看到世界尽头，但又不至于太近
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // 2. 相机
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 300);
            camera.position.set(5, 1.7, 30); // 初始位置

            // 3. 渲染器 (优化清晰度)
            renderer = new THREE.WebGLRenderer({ antialias: false }); // 关闭抗锯齿以保持像素硬边
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 关键修正：手动设置内部渲染分辨率，而不是依赖 pixelRatio
            onWindowResize(); 
            document.body.appendChild(renderer.domElement);

            // 4. 控制器
            controls = new PointerLockControls(camera, document.body);
            
            // 按钮逻辑：确保点击时初始化音频
            const btn = document.getElementById('start-btn');
            const overlay = document.getElementById('overlay');
            
            btn.addEventListener('click', async () => {
                overlay.style.display = 'none';
                controls.lock();
                await initAudio(); // 必须在用户点击时启动音频
                startAmbience();
                scheduleTrain(); // 启动列车倒计时
            });

            controls.addEventListener('unlock', () => {
                overlay.style.display = 'flex';
                btn.innerText = "点击继续";
            });

            scene.add(controls.getObject());

            // 5. 监听按键
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));

            // 6. 构建世界
            buildWorld();
            window.addEventListener('resize', onWindowResize);
        }

        function onKey(e, isDown) {
            switch(e.code) {
                case 'ArrowUp': case 'KeyW': moveF = isDown; break;
                case 'ArrowDown': case 'KeyS': moveB = isDown; break;
                case 'ArrowLeft': case 'KeyA': moveL = isDown; break;
                case 'ArrowRight': case 'KeyD': moveR = isDown; break;
                case 'ShiftLeft': case 'ShiftRight': isRunning = isDown; break;
            }
        }

        // --- 构建 3D 世界 ---
        function buildWorld() {
            // 材质
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.4 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 1.0 });
            const stripMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // 黄色警戒线

            // 站台地面
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 200), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(10, 0, 0); // 站台在 x>0
            scene.add(floor);

            // 警戒线
            const strip = new THREE.Mesh(new THREE.PlaneGeometry(1, 200), stripMat);
            strip.rotation.x = -Math.PI / 2;
            strip.position.set(-14, 0.01, 0); // 边缘
            scene.add(strip);

            // 轨道坑 (黑色虚空)
            const pit = new THREE.Mesh(new THREE.PlaneGeometry(30, 200), new THREE.MeshBasicMaterial({color: 0x000000}));
            pit.rotation.x = -Math.PI / 2;
            pit.position.set(-20, -3, 0);
            scene.add(pit);

            // 墙壁
            const wall = new THREE.Mesh(new THREE.PlaneGeometry(200, 20), wallMat);
            wall.rotation.y = -Math.PI / 2;
            wall.position.set(30, 10, 0);
            scene.add(wall);

            // 天花板
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(60, 200), wallMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.set(10, 15, 0);
            scene.add(ceil);

            // 灯光与柱子
            for(let z = -80; z <= 80; z += 20) {
                // 柱子
                const col = new THREE.Mesh(new THREE.BoxGeometry(2, 15, 2), wallMat);
                col.position.set(10, 7.5, z);
                scene.add(col);

                // 荧光灯 (冷色)
                const light = new THREE.PointLight(0x88ccff, 1.0, 30);
                light.position.set(10, 12, z);
                scene.add(light);
                
                // 灯管模型
                const bulb = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 4), new THREE.MeshBasicMaterial({color: 0xccffff}));
                bulb.position.set(10, 14.8, z);
                scene.add(bulb);
            }

            // --- 实体列车模型 (Group) ---
            trainGroup = new THREE.Group();
            
            // 车身 (长方体)
            const bodyGeo = new THREE.BoxGeometry(4.5, 5, 60);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x555555, roughness: 0.2, metalness: 0.8 
            });
            const trainBody = new THREE.Mesh(bodyGeo, bodyMat);
            trainBody.position.y = 2.5;
            trainGroup.add(trainBody);

            // 车窗 (发光材质)
            const winGeo = new THREE.BoxGeometry(4.6, 1.5, 50);
            const winMat = new THREE.MeshBasicMaterial({ color: 0xccffaa }); // 诡异的绿光车窗
            const windows = new THREE.Mesh(winGeo, winMat);
            windows.position.y = 3;
            trainGroup.add(windows);

            // 车头灯 (强聚光灯)
            const headLight = new THREE.SpotLight(0xffffee, 100, 150, 0.6, 0.5);
            headLight.position.set(0, 3, 31); // 车头最前端
            headLight.target.position.set(0, 1, 100);
            trainGroup.add(headLight);
            trainGroup.add(headLight.target);
            
            // 尾灯 (红光)
            const tailLight = new THREE.PointLight(0xff0000, 5, 20);
            tailLight.position.set(0, 3, -31);
            trainGroup.add(tailLight);

            // 初始隐藏在远处
            trainGroup.position.set(-20, -2, -300); 
            scene.add(trainGroup);
        }

        // --- 音频系统 (Prodecural Audio) ---
        async function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            
            // 强制恢复 (Chrome策略)
            if(audioCtx.state === 'suspended') await audioCtx.resume();
            
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.6; // 主音量
            masterGain.connect(audioCtx.destination);
        }

        // 1. 环境音 (低频嗡鸣 + 恐怖氛围)
        function startAmbience() {
            if(!audioCtx) return;
            
            // 创建两个振荡器产生不和谐音
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            
            osc1.frequency.value = 50; // 低音
            osc2.frequency.value = 53; // 稍微偏离产生 "Beat" 效果
            
            osc1.type = 'sawtooth';
            osc2.type = 'triangle';

            // 低通滤波器，让声音闷闷的
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 150;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.2;

            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            osc1.start();
            osc2.start();
            ambienceNode = { stop: () => { osc1.stop(); osc2.stop(); } };
        }

        // 2. 列车呼啸声 (粉红噪声 + 滤波器扫频)
        function playTrainSound(duration) {
            if(!audioCtx) return;
            
            const t = audioCtx.currentTime;
            
            // 生成噪声
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.8; // 白噪声
            }
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            // 带通滤波器模拟风声
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.Q.value = 1.0;
            // 频率变化模拟多普勒：低 -> 高 (靠近) -> 低 (远去)
            filter.frequency.setValueAtTime(100, t);
            filter.frequency.exponentialRampToValueAtTime(800, t + duration * 0.4); // 进站
            filter.frequency.exponentialRampToValueAtTime(100, t + duration); // 出站

            // 声相 (3D位置)
            const panner = audioCtx.createPanner();
            panner.panningModel = 'HRTF';
            panner.positionY.value = 0;
            panner.positionX.value = -10; // 轨道在左侧
            // Z轴移动
            panner.positionZ.setValueAtTime(-100, t); 
            panner.positionZ.linearRampToValueAtTime(100, t + duration);

            // 音量包络
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(2.0, t + duration * 0.4); // 最大声
            gain.gain.linearRampToValueAtTime(0, t + duration);

            noise.connect(filter).connect(gain).connect(panner).connect(masterGain);
            noise.start();
        }

        // --- 游戏逻辑 ---

        function scheduleTrain() {
            setTimeout(() => {
                spawnTrain();
                scheduleTrain(); // 循环
            }, TRAIN_INTERVAL);
        }

        function spawnTrain() {
            trainMoving = true;
            trainStartTime = performance.now();
            
            // 播放声音 (持续 8 秒)
            playTrainSound(8); 
        }

        function updateTrain(dt, time) {
            if(!trainMoving) return;

            // 模拟列车通过的时间 (8000ms)
            const duration = 8000;
            const elapsed = time - trainStartTime;
            const progress = elapsed / duration;

            if (progress <= 1.2) { // 稍微多跑一点
                // 从 Z-250 移动到 Z+250
                const startZ = -250;
                const endZ = 250;
                const currentZ = startZ + (endZ - startZ) * progress;
                
                trainGroup.position.z = currentZ;
                
                // 列车震动效果
                trainGroup.position.y = -2 + Math.sin(time * 0.05) * 0.05;

            } else {
                trainMoving = false;
                trainGroup.position.z = -300; // 重置到远处
            }
        }

        // --- 核心循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // 1. 移动逻辑
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveF) - Number(moveB);
                direction.x = Number(moveR) - Number(moveL);
                direction.normalize();

                // 疾跑倍率
                const speedMulti = isRunning ? RUN_SPEED : BASE_SPEED;

                if (moveF || moveB) velocity.z -= direction.z * speedMulti * delta;
                if (moveL || moveR) velocity.x -= direction.x * speedMulti * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // 2. 动态 FOV (疾跑时的速度感)
                const targetFOV = isRunning && (moveF || moveB) ? 100 : 85;
                camera.fov += (targetFOV - camera.fov) * delta * 5; // 平滑插值
                camera.updateProjectionMatrix();

                // 3. 简单的脚步震动
                if (direction.length() > 0) {
                    const freq = isRunning ? 0.02 : 0.012;
                    const amp = isRunning ? 0.15 : 0.08;
                    camera.position.y = 1.7 + Math.sin(time * freq) * amp;
                }
            }

            // 4. 更新列车
            updateTrain(delta, time);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // 核心修复：保持画布全屏，但降低内部渲染分辨率
            // PIXEL_RATIO = 0.5 表示 1920x1080 屏幕渲染为 960x540，既有复古感又不会太糊
            const w = Math.floor(window.innerWidth * PIXEL_RATIO);
            const h = Math.floor(window.innerHeight * PIXEL_RATIO);
            renderer.setSize(w, h, false); // false = 不改变 Canvas CSS 尺寸
        }
    </script>
</body>
</html>
