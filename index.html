<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>深夜地铁站 | 操控修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; user-select: none; }
        canvas { width: 100%; height: 100%; display: block; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #111, #222);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 100;
        }
        #overlay h1 { font-size: 3rem; text-shadow: 0 0 20px #0ff; margin-bottom: 10px; }
        #start-btn {
            padding: 20px 60px; border: none; background: #0ff; color: #000;
            font-size: 1.5rem; font-weight: bold; cursor: pointer; border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); transition: 0.2s;
        }
        #start-btn:hover { transform: scale(1.05); background: #fff; }

        #ui { position: absolute; bottom: 30px; left: 30px; color: rgba(255,255,255,0.8); pointer-events: none; }
        .key { display: inline-block; background: #333; border: 1px solid #666; padding: 4px 8px; border-radius: 4px; margin: 0 2px; color: #fff; font-weight: bold; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%);
            border: 1px solid rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>V3.1 FIXED</h1>
        <p style="color: #aaa; margin-bottom: 30px;">操控系统重构 • 物理碰撞 • 实体列车</p>
        <button id="start-btn">启动引擎 (INITIALIZE)</button>
    </div>

    <div id="crosshair"></div>
    <div id="ui">
        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移动 
        <span class="key">SPACE</span> 跳跃 
        <span class="key">SHIFT</span> 疾跑
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 核心参数 ---
        const CONFIG = {
            gravity: 25.0,     // 重力加速度
            moveSpeed: 15.0,   // 走路速度
            runSpeed: 30.0,    // 跑步速度
            jumpForce: 10.0,   // 跳跃高度
            eyeHeight: 1.7,    // 眼睛高度
            playerRadius: 0.6  // 碰撞半径
        };

        // 全局变量
        let camera, scene, renderer, controls;
        let moveF=false, moveB=false, moveL=false, moveR=false, isRunning=false;
        let canJump = false;
        let velocityY = 0; // 垂直速度单独控制
        let prevTime = performance.now();

        // 碰撞数据
        const walls = [];   // Box3 数组
        const pillars = []; // {x, z, r} 数组

        // 场景对象
        let trainGroup, trainActive = false, trainStart = 0;
        let audioCtx, masterGain;

        init();
        animate();

        function init() {
            // 1. 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111115);
            scene.fog = new THREE.FogExp2(0x111115, 0.015);

            // 2. 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
            
            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比以保证性能
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. 灯光 (保证不黑)
            const amb = new THREE.AmbientLight(0x666677, 1.2); 
            scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(30, 50, 20);
            dir.castShadow = true;
            dir.shadow.mapSize.set(2048, 2048);
            scene.add(dir);

            // 5. 控制器
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // 关键：将控制器对象加入场景

            // 按钮逻辑
            const btn = document.getElementById('start-btn');
            const overlay = document.getElementById('overlay');
            
            // 初始安全位置 (Y=2.5 防止卡地板)
            controls.getObject().position.set(10, 2.5, 0);

            btn.addEventListener('click', async () => {
                overlay.style.display = 'none';
                controls.lock();
                await initAudio();
                startLoopAudio();
                setInterval(spawnTrain, 15000); // 15秒刷车
            });

            controls.addEventListener('unlock', () => {
                overlay.style.display = 'flex';
                btn.innerText = "回到游戏 (RESUME)";
            });

            // 6. 输入监听
            document.addEventListener('keydown', onKey(true));
            document.addEventListener('keyup', onKey(false));

            // 7. 搭建世界
            buildWorld();
            
            window.addEventListener('resize', onResize);
        }

        // --- 物理移动核心 (重写版) ---
        function updatePhysics(dt) {
            // 限制最大 dt 防止切换标签时穿墙
            const delta = Math.min(dt, 0.1); 

            const obj = controls.getObject(); // 这是相机的包装容器
            const pos = obj.position;

            // 1. 水平移动计算 (使用 Math.sin/cos 确保稳定)
            // 获取摄像机的水平朝向角度 (Yaw)
            // PointerLockControls 内部对象结构: obj.rotation.y 是水平旋转
            const yaw = obj.rotation.y; 
            const speed = isRunning ? CONFIG.runSpeed : CONFIG.moveSpeed;

            let dx = 0;
            let dz = 0;

            if (moveF) { dx -= Math.sin(yaw); dz -= Math.cos(yaw); }
            if (moveB) { dx += Math.sin(yaw); dz += Math.cos(yaw); }
            if (moveL) { dx -= Math.cos(yaw); dz += Math.sin(yaw); } // 左是 Yaw - 90度
            if (moveR) { dx += Math.cos(yaw); dz -= Math.sin(yaw); }

            // 归一化并应用速度
            if (dx !== 0 || dz !== 0) {
                const len = Math.sqrt(dx*dx + dz*dz);
                dx = (dx / len) * speed * delta;
                dz = (dz / len) * speed * delta;
            }

            // 2. 尝试 X 轴移动与碰撞检测
            const originalX = pos.x;
            pos.x += dx;
            if (checkWallCollision(pos)) {
                pos.x = originalX; // 撞墙回退
            }

            // 3. 尝试 Z 轴移动与碰撞检测
            const originalZ = pos.z;
            pos.z += dz;
            if (checkWallCollision(pos)) {
                pos.z = originalZ; // 撞墙回退
            }

            // 4. 垂直移动 (重力)
            velocityY -= CONFIG.gravity * delta;
            pos.y += velocityY * delta;

            // 5. 地面检测
            // 站台区: X > 0, 高度 0
            // 轨道区: X <= 0, 高度 -3
            const groundHeight = (pos.x > 0) ? 0 : -3.0;
            const playerBottom = pos.y - CONFIG.eyeHeight;

            // 如果脚底掉到了地面以下
            if (playerBottom < groundHeight) {
                pos.y = groundHeight + CONFIG.eyeHeight;
                velocityY = 0;
                canJump = true;
            }

            // 6. 撞车检测
            if (trainActive && pos.x <= 0) { // 只有在轨道区才会被撞
                // 简单的 Z 轴范围检测
                const trainZ = trainGroup.position.z;
                if (Math.abs(pos.z - trainZ) < 40) { // 车长范围
                    // 被撞飞
                    velocityY = 15;
                    pos.x = 10; // 强制弹回站台
                    playHitSound();
                }
            }
        }

        // 碰撞检测工具
        function checkWallCollision(p) {
            const r = CONFIG.playerRadius;
            
            // 1. 柱子检测 (圆柱体)
            for(let col of pillars) {
                const distSq = (p.x - col.x)**2 + (p.z - col.z)**2;
                if (distSq < (col.r + r)**2) return true;
            }

            // 2. 墙壁检测 (Box3)
            // 构造玩家当前的 AABB
            const playerBox = new THREE.Box3();
            playerBox.min.set(p.x - r, p.y - CONFIG.eyeHeight, p.z - r);
            playerBox.max.set(p.x + r, p.y, p.z + r);

            for(let wall of walls) {
                if (wall.intersectsBox(playerBox)) return true;
            }

            return false;
        }

        // --- 构建世界 ---
        function buildWorld() {
            // 材质
            const mFloor = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
            const mWall = new THREE.MeshStandardMaterial({ color: 0x666666 });
            
            // 1. 站台
            const floor = new THREE.Mesh(new THREE.BoxGeometry(30, 1, 300), mFloor);
            floor.position.set(15, -0.5, 0); // Surface at y=0
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. 轨道床
            const track = new THREE.Mesh(new THREE.PlaneGeometry(50, 300), new THREE.MeshStandardMaterial({color: 0x111111}));
            track.rotation.x = -Math.PI/2;
            track.position.set(-25, -3, 0);
            scene.add(track);

            // 3. 后墙 (实体墙)
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(2, 40, 300), mWall);
            backWall.position.set(31, 20, 0);
            backWall.castShadow = true;
            scene.add(backWall);
            
            // 碰撞体: 后墙
            walls.push(new THREE.Box3(
                new THREE.Vector3(30, -10, -150), 
                new THREE.Vector3(32, 50, 150)
            ));

            // 碰撞体: 边界隐形墙
            walls.push(new THREE.Box3(new THREE.Vector3(-100, -10, -152), new THREE.Vector3(100, 50, -150))); // Front
            walls.push(new THREE.Box3(new THREE.Vector3(-100, -10, 150), new THREE.Vector3(100, 50, 152)));   // Back
            walls.push(new THREE.Box3(new THREE.Vector3(-40, -10, -150), new THREE.Vector3(-38, 50, 150)));   // Left limit

            // 4. 柱子
            const colGeo = new THREE.CylinderGeometry(1.2, 1.2, 12, 16);
            for(let z=-100; z<=100; z+=25) {
                const mesh = new THREE.Mesh(colGeo, mWall);
                mesh.position.set(8, 6, z);
                mesh.castShadow = true;
                scene.add(mesh);
                
                // 灯光
                const l = new THREE.PointLight(0xaaddff, 1.5, 20);
                l.position.set(8, 10, z);
                scene.add(l);

                // 物理数据
                pillars.push({x: 8, z: z, r: 1.2});
            }

            // 5. 实体列车组
            trainGroup = new THREE.Group();
            const tBody = new THREE.Mesh(new THREE.BoxGeometry(4.2, 4.5, 80), new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.6}));
            tBody.position.y = 2.25; // Base at 0 relative to group
            trainGroup.add(tBody);
            
            const tHead = new THREE.SpotLight(0xffffff, 100, 150);
            tHead.position.set(0, 3, 40);
            tHead.target.position.set(0, 1, 100);
            trainGroup.add(tHead);
            trainGroup.add(tHead.target);
            
            trainGroup.position.set(-6, -3, -500);
            scene.add(trainGroup);
        }

        // --- 逻辑控制 ---
        function onKey(isDown) {
            return (e) => {
                switch(e.code) {
                    case 'KeyW': moveF = isDown; break;
                    case 'KeyS': moveB = isDown; break;
                    case 'KeyA': moveL = isDown; break;
                    case 'KeyD': moveR = isDown; break;
                    case 'ShiftLeft': isRunning = isDown; break;
                    case 'Space': 
                        if(isDown && canJump) {
                            velocityY = CONFIG.jumpForce;
                            canJump = false;
                        } 
                        break;
                }
            };
        }

        function spawnTrain() {
            if(trainActive) return;
            trainActive = true;
            trainStart = performance.now();
            playTrainSound();
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                updatePhysics(delta);
            }

            // 列车动画
            if (trainActive) {
                const dur = 6000; // 6秒通过
                const elap = time - trainStart;
                const pct = elap / dur;
                if (pct < 1.5) {
                    trainGroup.position.z = -300 + (600 * pct);
                } else {
                    trainActive = false;
                    trainGroup.position.z = -500;
                }
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 简易音频 ---
        async function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            if(audioCtx.state === 'suspended') await audioCtx.resume();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.4;
            masterGain.connect(audioCtx.destination);
        }

        function startLoopAudio() {
            const osc = audioCtx.createOscillator();
            osc.frequency.value = 50;
            const g = audioCtx.createGain();
            g.gain.value = 0.05;
            osc.connect(g).connect(masterGain);
            osc.start();
        }

        function playTrainSound() {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, t);
            osc.frequency.exponentialRampToValueAtTime(150, t+3);
            
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.5, t+3);
            g.gain.linearRampToValueAtTime(0, t+6);
            
            osc.connect(g).connect(masterGain);
            osc.start(); osc.stop(t+6);
        }

        function playHitSound() {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.frequency.value = 100;
            osc.type = 'square';
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.5, t);
            g.gain.exponentialRampToValueAtTime(0.01, t+0.3);
            osc.connect(g).connect(masterGain);
            osc.start(); osc.stop(t+0.3);
        }

    </script>
</body>
</html>
