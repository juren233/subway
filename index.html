<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>深夜无人地铁站 | PS1 Style Fixed</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace; 
            user-select: none; /* 防止选中文本 */
        }
        
        /* 核心修正：画布样式 */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* 强制像素化渲染，防止模糊 */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ddd;
            z-index: 100;
            cursor: default;
        }

        #start-btn {
            padding: 15px 40px;
            border: 2px solid #fff;
            background: transparent;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-top: 20px;
            transition: all 0.3s;
        }
        #start-btn:hover { background: #fff; color: #000; }

        /* UI层核心修正：禁止UI阻挡鼠标事件 */
        #ui-layer, #interaction-text, #controls-hint {
            pointer-events: none; 
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            z-index: 50;
        }

        #crosshair {
            width: 6px; height: 6px;
            background: red;
            border-radius: 50%;
            box-shadow: 0 0 4px white;
        }

        #interaction-text {
            position: absolute;
            bottom: 30%;
            width: 100%;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px; left: 20px;
            color: #888;
            font-size: 1rem;
            z-index: 50;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 style="text-shadow: 0 0 15px #44f; font-size: 3rem;">VOID STATION</h1>
        <p>视野已修正 | Use Headphones</p>
        <button id="start-btn">CLICK TO START</button>
    </div>

    <div id="ui-layer"><div id="crosshair"></div></div>
    <div id="interaction-text"></div>
    <div id="controls-hint">WASD: Move | Mouse: Look | Click: Interact</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 全局变量 ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let isSitting = false;
        let raycaster = new THREE.Raycaster();
        let center = new THREE.Vector2(0, 0); 
        let textTimeout;

        let trainLightGroup;
        let fluorescentLights = [];
        let particles;

        // 音频相关
        let audioCtx, masterGain, reverbNode;
        let nextTrainTime = 0;
        let lastFootstepTime = 0;
        let hasInteracted = false;

        // 渲染配置
        const PIXEL_RATIO = 0.2; // 值越小越像素化，0.2 = 1/5分辨率
        const TRAIN_INTERVAL = 40000;

        init();
        animate();

        function init() {
            // 1. 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.025);

            // 2. 相机 (FOV 修正为 100，解决放大感)
            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.y = 1.7;

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            // 关键：不使用默认的 devicePixelRatio，强制为1，确保像素颗粒感清晰
            renderer.setPixelRatio(1); 
            // 初始设置大小 (稍后 resize 会修正)
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // 立即执行一次 Resize 逻辑以确保分辨率正确
            onWindowResize();

            // 4. 控制器
            controls = new PointerLockControls(camera, document.body);
            const overlay = document.getElementById('overlay');
            const startBtn = document.getElementById('start-btn');

            // 核心修复：点击按钮 -> 隐藏遮罩 -> 锁定鼠标
            startBtn.addEventListener('click', () => {
                overlay.style.display = 'none';
                controls.lock();
                if (!hasInteracted) {
                    initAudio();
                    scheduleNextTrain();
                    hasInteracted = true;
                }
            });

            // 监听锁定状态，如果用户按ESC退出，显示遮罩
            controls.addEventListener('unlock', () => {
                if (!isSitting) {
                    overlay.style.display = 'flex';
                    document.querySelector('#overlay h1').innerText = "PAUSED";
                    startBtn.innerText = "RESUME";
                }
            });

            scene.add(controls.getObject());

            // 5. 输入事件
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', () => {
                // 如果在游戏中点击，触发交互
                if (controls.isLocked || isSitting) onInteract();
            });

            buildStation();
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            // 1. 更新相机宽高比
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // 2. 核心修正：
            // setSize 第三个参数 false 表示：只改变内部渲染缓冲区的尺寸，不改变 Canvas 的 style 尺寸。
            // 这样 Canvas 依然撑满屏幕 (CSS: 100%)，但内容是低分辨率的 (Internal: W*Ratio)。
            const lowResW = Math.floor(window.innerWidth * PIXEL_RATIO);
            const lowResH = Math.floor(window.innerHeight * PIXEL_RATIO);
            renderer.setSize(lowResW, lowResH, false);
        }

        // --- 场景构建 (保持原有氛围) ---
        function buildStation() {
            const wetFloorMat = new THREE.MeshStandardMaterial({ 
                color: 0x111115, roughness: 0.05, metalness: 0.6 
            });
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333, roughness: 0.9 
            });

            // 地面
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 150), wetFloorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(10, 0, 0);
            scene.add(floor);

            // 轨道坑
            const trackPit = new THREE.Mesh(new THREE.PlaneGeometry(20, 150), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            trackPit.rotation.x = -Math.PI / 2;
            trackPit.position.set(-15, -2, 0);
            scene.add(trackPit);

            // 墙面与天花板
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(150, 20), wallMat);
            backWall.position.set(25, 10, 0);
            backWall.rotation.y = -Math.PI / 2;
            scene.add(backWall);

            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(60, 150), wallMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(10, 12, 0);
            scene.add(ceiling);

            // 柱子阵列
            const colGeo = new THREE.CylinderGeometry(0.8, 0.8, 12, 8);
            for(let z=-60; z<=60; z+=15) {
                const col = new THREE.Mesh(colGeo, wallMat);
                col.position.set(5, 6, z);
                scene.add(col);
            }

            // 荧光灯
            for(let z=-50; z<=50; z+=20) {
                const lightMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 5), new THREE.MeshBasicMaterial({ color: 0xaaccff }));
                lightMesh.position.set(12, 11.5, z);
                scene.add(lightMesh);

                const pointLight = new THREE.PointLight(0x88bbff, 1.5, 25);
                pointLight.position.set(12, 10, z);
                scene.add(pointLight);

                fluorescentLights.push({ mesh: lightMesh, light: pointLight, flicker: Math.random() * 100 });
            }

            // 自动售货机
            const vmGroup = new THREE.Group();
            const vmBody = new THREE.Mesh(new THREE.BoxGeometry(2, 3.5, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            vmBody.position.y = 1.75;
            vmGroup.add(vmBody);
            
            const vmScreen = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 1), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
            vmScreen.position.set(0, 2, -1.01);
            vmScreen.rotation.y = Math.PI;
            vmGroup.add(vmScreen);
            
            const vmLit = new THREE.PointLight(0x00ffcc, 1, 8);
            vmLit.position.set(0, 2, -2);
            vmGroup.add(vmLit);
            
            vmGroup.position.set(20, 0, -10);
            vmGroup.name = "vending_machine";
            scene.add(vmGroup);

            // 长椅
            const bench = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x5a3d2b }));
            bench.position.set(18, 0.5, 10);
            bench.name = "bench";
            scene.add(bench);

            // 灰尘粒子
            const pGeo = new THREE.BufferGeometry();
            const pCount = 800;
            const pPos = [];
            for(let i=0; i<pCount; i++) {
                pPos.push((Math.random()-0.5)*80, (Math.random())*15, (Math.random()-0.5)*150);
            }
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0x666666, size: 0.2, transparent: true, opacity: 0.5 }));
            scene.add(particles);

            // 幽灵列车光效
            trainLightGroup = new THREE.Group();
            const tHead = new THREE.SpotLight(0xffffff, 50, 200, 0.5, 0.8);
            tHead.position.set(0, 3, 0);
            tHead.target.position.set(0, 3, 20);
            trainLightGroup.add(tHead);
            trainLightGroup.add(tHead.target);
            trainLightGroup.position.set(-10, 0, -200);
            scene.add(trainLightGroup);
        }

        // --- 逻辑控制 ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (isSitting) standUp(); break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        function onInteract() {
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                // 向上查找 group 名称
                let obj = intersects[0].object;
                while(obj.parent && obj.parent.type !== 'Scene') {
                    if(obj.name) break;
                    obj = obj.parent;
                }
                
                const dist = intersects[0].point.distanceTo(camera.position);

                if (obj.name === 'vending_machine' && dist < 6) {
                    showMsg("贩卖：昨日的遗憾 - 库存不足");
                    playTone(600, 0.1);
                } else if (obj.name === 'bench' && dist < 6 && !isSitting) {
                    sitDown(obj);
                }
            }
        }

        function sitDown(bench) {
            isSitting = true;
            controls.unlock(); // 解锁让鼠标可见，但限制移动
            
            // 简单瞬移
            camera.position.set(bench.position.x, 1.2, bench.position.z);
            camera.lookAt(-20, 0, bench.position.z); // 强制看向轨道
            
            showMsg("已坐下。静静等待... (按空格起立)");
            document.getElementById('crosshair').style.display = 'none';
        }

        function standUp() {
            isSitting = false;
            camera.position.y = 1.7;
            controls.lock();
            document.getElementById('crosshair').style.display = 'block';
        }

        function showMsg(text) {
            const el = document.getElementById('interaction-text');
            el.innerText = text;
            el.style.opacity = 1;
            clearTimeout(textTimeout);
            textTimeout = setTimeout(() => el.style.opacity = 0, 3000);
        }

        // --- 音频系统 (简易版) ---
        function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.4;
            
            // 简单混响
            reverbNode = audioCtx.createConvolver();
            // 生成噪声作为IR
            const rate = audioCtx.sampleRate;
            const length = rate * 2;
            const impulse = audioCtx.createBuffer(2, length, rate);
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 3);
                impulse.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
                impulse.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
            }
            reverbNode.buffer = impulse;
            reverbNode.connect(masterGain);
            masterGain.connect(audioCtx.destination);

            // 背景底噪
            const osc = audioCtx.createOscillator();
            osc.frequency.value = 50;
            const droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.05;
            osc.connect(droneGain).connect(reverbNode);
            osc.start();
        }

        function playTone(freq, dur) {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            osc.frequency.value = freq;
            osc.type = 'triangle';
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.1, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.connect(g).connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playFootstep() {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const noise = audioCtx.createBufferSource();
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
            noise.buffer = buf;
            
            const f = audioCtx.createBiquadFilter();
            f.type = "lowpass"; f.frequency.value = 300;
            
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.2, t);
            g.gain.exponentialRampToValueAtTime(0.01, t+0.05);
            
            noise.connect(f).connect(g).connect(reverbNode);
            noise.start();
        }

        function playTrain() {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const dur = 10;
            
            // 噪音源
            const bSize = audioCtx.sampleRate * dur;
            const buf = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for(let i=0; i<bSize; i++) data[i] = Math.random()*2-1;
            
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            
            // 滤波器模拟远近
            const filter = audioCtx.createBiquadFilter();
            filter.frequency.setValueAtTime(100, t);
            filter.frequency.linearRampToValueAtTime(2000, t + dur/2);
            filter.frequency.linearRampToValueAtTime(100, t + dur);
            
            // 声相模拟移动
            const panner = audioCtx.createPanner();
            panner.panningModel = 'HRTF';
            panner.positionZ.setValueAtTime(-100, t);
            panner.positionZ.linearRampToValueAtTime(100, t + dur);
            panner.positionX.value = -10; 
            
            src.connect(filter).connect(panner).connect(masterGain);
            src.start();
            
            animateTrain(dur);
        }
        
        function scheduleNextTrain() {
            nextTrainTime = performance.now() + TRAIN_INTERVAL;
        }

        function animateTrain(durSeconds) {
            const startT = performance.now();
            const dur = durSeconds * 1000;
            const startZ = -150;
            const endZ = 150;
            
            function loop() {
                const elapsed = performance.now() - startT;
                const pct = elapsed / dur;
                if (pct <= 1) {
                    trainLightGroup.position.z = startZ + (endZ - startZ) * pct;
                    requestAnimationFrame(loop);
                } else {
                    trainLightGroup.position.z = -200;
                }
            }
            loop();
        }

        // --- 主循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            
            // 控制逻辑
            if (controls.isLocked) {
                const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 60.0 * delta; // 提高一点速度
                if (moveLeft || moveRight) velocity.x -= direction.x * 60.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // 脚步声
                if (direction.length() > 0 && time - lastFootstepTime > 500) {
                    playFootstep();
                    lastFootstepTime = time;
                    camera.position.y = 1.7 + Math.sin(time*0.015)*0.05;
                }
            }

            // 视觉特效更新
            fluorescentLights.forEach(l => {
                if(Math.random()*100 < 2) l.light.intensity = Math.random();
                else l.light.intensity = 1.2;
            });
            
            const pa = particles.geometry.attributes.position.array;
            for(let i=1; i<pa.length; i+=3) pa[i] = (pa[i] + 0.02) % 15;
            particles.geometry.attributes.position.needsUpdate = true;

            // 地铁检查
            if (hasInteracted && time > nextTrainTime) {
                playTrain();
                scheduleNextTrain();
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
