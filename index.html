<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>深夜地铁站 | 高清重制版</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            user-select: none; 
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* 移除像素化滤镜，使用平滑渲染 */
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 100;
        }

        h1 {
            font-size: 3rem; margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }

        #start-btn {
            padding: 15px 60px; 
            border: none; border-radius: 4px;
            background: #fff; color: #1a1a2e;
            font-size: 1.2rem; font-weight: bold;
            cursor: pointer; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        #start-btn:active { transform: scale(0.95); }

        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; 
            background: rgba(255, 255, 255, 0.9); border-radius: 50%; 
            transform: translate(-50%, -50%); 
            box-shadow: 0 0 4px #fff;
        }
        
        #tips {
            position: absolute; bottom: 30px; left: 30px; 
            color: rgba(255,255,255,0.7); font-size: 1rem;
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 8px;
        }
        .key { color: #fff; font-weight: bold; border: 1px solid #aaa; padding: 0 6px; border-radius: 4px; margin: 0 2px; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>SUBWAY STATION</h1>
        <p style="margin-bottom: 40px; color: #aab;">高清模式 • 声音合成 • 实体列车</p>
        <button id="start-btn">点击开始体验</button>
    </div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="tips">
            <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移动 
            <span class="key">SHIFT</span> 按住疾跑 
            <span class="key">鼠标</span> 环顾
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 参数配置 ---
        const TRAIN_INTERVAL = 15000; // 缩短等待时间：15秒一班车
        const RUN_FOV = 100;
        const NORMAL_FOV = 75;

        // --- 全局变量 ---
        let camera, scene, renderer, controls;
        let moveF = false, moveB = false, moveL = false, moveR = false, isRunning = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // 场景对象
        let trainGroup;
        let trainMoving = false;
        let trainStartTime = 0;
        
        // 音频
        let audioCtx, masterGain;

        init();
        animate();

        function init() {
            // 1. 场景颜色调亮
            scene = new THREE.Scene();
            // 深蓝色背景，不再是死黑
            scene.background = new THREE.Color(0x1a1a2e); 
            // 雾气改淡，让视野更远
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.012); 

            // 2. 相机
            camera = new THREE.PerspectiveCamera(NORMAL_FOV, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 1.7, 10);

            // 3. 渲染器 (高清设置)
            // 开启抗锯齿(antialias: true)，开启高精度深度缓冲
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio); // 使用屏幕原生像素比，拒绝模糊
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 开启阴影贴图
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. 灯光系统 (大幅增强)
            setupLighting();

            // 5. 控制器
            controls = new PointerLockControls(camera, document.body);
            const startBtn = document.getElementById('start-btn');
            const overlay = document.getElementById('overlay');

            startBtn.addEventListener('click', async () => {
                overlay.style.display = 'none';
                controls.lock();
                await initAudio();
                startBackgroundNoise();
                // 立即安排一班车，不用等太久
                setTimeout(spawnTrain, 3000); 
                scheduleTrain();
            });

            controls.addEventListener('unlock', () => {
                overlay.style.display = 'flex';
                startBtn.innerText = "回到游戏";
            });
            scene.add(controls.getObject());

            // 6. 交互
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));

            // 7. 构建场景
            buildStation();
            
            window.addEventListener('resize', onWindowResize);
        }

        function setupLighting() {
            // 环境光：基础亮度，保证阴影处可见
            const ambient = new THREE.AmbientLight(0x404050, 1.5); 
            scene.add(ambient);

            // 方向光：模拟月光/远处的城市光
            const dirLight = new THREE.DirectionalLight(0xaaccff, 0.5);
            dirLight.position.set(50, 50, 50);
            scene.add(dirLight);
        }

        function onKey(e, isDown) {
            switch(e.code) {
                case 'ArrowUp': case 'KeyW': moveF = isDown; break;
                case 'ArrowDown': case 'KeyS': moveB = isDown; break;
                case 'ArrowLeft': case 'KeyA': moveL = isDown; break;
                case 'ArrowRight': case 'KeyD': moveR = isDown; break;
                case 'ShiftLeft': case 'ShiftRight': isRunning = isDown; break;
            }
        }

        // --- 场景构建 ---
        function buildStation() {
            // 材质：更亮，反光度更高
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x555566, // 亮灰色水泥
                roughness: 0.4, 
                metalness: 0.2 
            });
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x888899, // 浅灰墙壁
                roughness: 0.8 
            });
            const yellowLineMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

            // 1. 站台地面
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 300), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(15, 0, 0);
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. 黄色警戒线 (很亮)
            const line = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 300), yellowLineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set(-8, 0.01, 0);
            scene.add(line);

            // 3. 轨道区域 (不再死黑)
            const trackBed = new THREE.Mesh(new THREE.PlaneGeometry(40, 300), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            trackBed.rotation.x = -Math.PI / 2;
            trackBed.position.set(-25, -2, 0);
            scene.add(trackBed);
            
            // 铁轨
            const railGeo = new THREE.BoxGeometry(0.2, 0.2, 300);
            const railMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8 });
            const rail1 = new THREE.Mesh(railGeo, railMat); rail1.position.set(-15, -1.8, 0);
            const rail2 = new THREE.Mesh(railGeo, railMat); rail2.position.set(-20, -1.8, 0);
            scene.add(rail1); scene.add(rail2);

            // 4. 对面墙壁
            const farWall = new THREE.Mesh(new THREE.PlaneGeometry(300, 30), wallMat);
            farWall.rotation.y = Math.PI / 2;
            farWall.position.set(-30, 10, 0);
            farWall.receiveShadow = true;
            scene.add(farWall);

            // 5. 天花板
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(100, 300), wallMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.set(0, 12, 0);
            scene.add(ceil);

            // 6. 柱子与高亮灯光
            const colGeo = new THREE.CylinderGeometry(1, 1, 12, 16);
            for(let z = -100; z <= 100; z += 25) {
                // 柱子
                const col = new THREE.Mesh(colGeo, wallMat);
                col.position.set(8, 6, z);
                col.castShadow = true;
                col.receiveShadow = true;
                scene.add(col);

                // 荧光灯模型
                const bulb = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                bulb.position.set(8, 11, z);
                scene.add(bulb);

                // 真实光源 (PointLight) - 增加范围和亮度
                const light = new THREE.PointLight(0xddeeff, 2, 40); // 强度2, 范围40米
                light.position.set(8, 10, z);
                light.castShadow = true;
                scene.add(light);
            }

            // --- 实体列车组 ---
            createTrain();
        }

        function createTrain() {
            trainGroup = new THREE.Group();
            
            // 车体
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 4.5, 60),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.2 }) // 银色金属车身
            );
            body.position.y = 2.25;
            trainGroup.add(body);

            // 车窗光条
            const windows = new THREE.Mesh(
                new THREE.BoxGeometry(4.1, 1, 55),
                new THREE.MeshBasicMaterial({ color: 0xaaffff }) // 亮青色车窗
            );
            windows.position.y = 2.8;
            trainGroup.add(windows);

            // 强力车头灯 (SpotLight)
            const headLight = new THREE.SpotLight(0xffffff, 200);
            headLight.angle = 0.6;
            headLight.penumbra = 0.5;
            headLight.distance = 200;
            headLight.position.set(0, 3, 30);
            headLight.target.position.set(0, 0, 100);
            trainGroup.add(headLight);
            trainGroup.add(headLight.target);
            
            // 车头灯光晕 (Sprite)
            const spriteMat = new THREE.SpriteMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const flare = new THREE.Sprite(spriteMat);
            flare.scale.set(4, 4, 1);
            flare.position.set(0, 3, 30.5);
            trainGroup.add(flare);

            trainGroup.position.set(-17.5, -2, -400); // 隐藏在远处
            scene.add(trainGroup);
        }

        // --- 音频逻辑 (纯代码合成) ---
        async function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            if(audioCtx.state === 'suspended') await audioCtx.resume();
            
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;
            masterGain.connect(audioCtx.destination);
        }

        function startBackgroundNoise() {
            // 产生低沉的空洞风声
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400; // 只要低频

            const gain = audioCtx.createGain();
            gain.gain.value = 0.05;

            noise.connect(filter).connect(gain).connect(masterGain);
            noise.start();
        }

        function playTrainSound(duration) {
            const t = audioCtx.currentTime;
            
            // 振荡器模拟电机声
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + duration/2); // 进站音调升高
            
            // 噪音模拟风声
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            // 滤波器扫频 (多普勒感)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(100, t);
            filter.frequency.exponentialRampToValueAtTime(2000, t + duration/2);
            filter.frequency.exponentialRampToValueAtTime(100, t + duration);

            // 3D 声像 (Panner)
            const panner = audioCtx.createPanner();
            panner.panningModel = 'HRTF';
            panner.positionX.value = -10;
            panner.positionY.value = 0;
            panner.positionZ.setValueAtTime(-200, t);
            panner.positionZ.linearRampToValueAtTime(200, t + duration);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(1.0, t + duration/2);
            gain.gain.linearRampToValueAtTime(0, t + duration);

            // 连接图
            osc.connect(gain);
            noise.connect(filter).connect(gain);
            gain.connect(panner).connect(masterGain);

            osc.start();
            noise.start();
            osc.stop(t + duration);
        }

        // --- 逻辑循环 ---

        function scheduleTrain() {
            setTimeout(() => {
                spawnTrain();
                scheduleTrain();
            }, TRAIN_INTERVAL);
        }

        function spawnTrain() {
            if(trainMoving) return;
            trainMoving = true;
            trainStartTime = performance.now();
            playTrainSound(8); // 8秒的声音
        }

        function updateTrain(time) {
            if(!trainMoving) return;
            const duration = 8000; 
            const elapsed = time - trainStartTime;
            const progress = elapsed / duration;

            if (progress < 1.3) {
                // 实体列车移动: 从 z=-300 到 z=300
                const z = -300 + (600 * progress);
                trainGroup.position.z = z;
            } else {
                trainMoving = false;
                trainGroup.position.z = -400; // 重置
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // 物理模拟
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveF) - Number(moveB);
                direction.x = Number(moveR) - Number(moveL);
                direction.normalize();

                const speed = isRunning ? 100.0 : 40.0;
                if (moveF || moveB) velocity.z -= direction.z * speed * delta;
                if (moveL || moveR) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // 疾跑时视角拉伸 (FOV 变化)
                const targetFOV = isRunning && (direction.length() > 0) ? RUN_FOV : NORMAL_FOV;
                const lerpSpeed = delta * 5;
                camera.fov += (targetFOV - camera.fov) * lerpSpeed;
                camera.updateProjectionMatrix();

                // 简单的头部晃动
                if (direction.length() > 0) {
                    camera.position.y = 1.7 + Math.sin(time * (isRunning ? 0.015 : 0.01)) * 0.1;
                }
            }

            updateTrain(time);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
